---
title: "Distributions"
author:
date: 
urlcolor: blue
output: 
  html_document:
    toc: TRUE
    toc_depth: 3
    toc_float: true
    number_sections: true
    highlight: tango
    theme: default
    fig_caption: true
    df_print: default
---

<style>
pre code, pre, code {
  white-space: pre !important;
  overflow-x: auto !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}
</style>

```{r global options, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
options(tibble.width = Inf, width = 10000, scipen = 999)
```

**Load packages**:

```{r, message = FALSE}
library(tidyverse)
library(labelled)
```

**Resources**:

- https://www.datamentor.io/r-programming/examples/random-number/
- https://stackoverflow.com/questions/28099590/create-sample-vector-data-in-r-with-a-skewed-distribution-with-limited-range
- http://www.sthda.com/english/wiki/ggplot2-density-plot-quick-start-guide-r-software-and-data-visualization
- https://datavizpyr.com/add-vertical-line-to-density-plot-with-ggplot2/
- https://stackoverflow.com/questions/37660694/add-legend-to-geom-vline
- https://campus.datacamp.com/courses/statistical-inference-and-data-analysis/lab-3a-foundations-for-inference-sampling-distributions?ex=6
- https://ggplot2-book.org/arranging-plots.html
- https://www.statology.org/t-critical-value-r/
- https://www.statology.org/p-value-of-t-score-r/


# Generate random distributions

```{r}
num_obs <- 500

# Generate standard normal distribution (default is mean = 0 and sd = 1)
set.seed(124)
stdnorm_dist <- rnorm(num_obs, mean = 0, sd = 1)  # equivalent to rnorm(10)

# Generate normal distribution w/ custom mean and sd
set.seed(124)
norm_dist <- rnorm(num_obs, mean = 10, sd = 2)

# Generate left-skewed distribution
set.seed(124)
lskew_dist <- rbeta(num_obs, 5, 2)

# Generate right-skewed distribution
set.seed(124)
rskew_dist <- rbeta(num_obs, 2, 5)

# Create dataframe
df_generated_pop <- data.frame(stdnorm_dist, norm_dist, lskew_dist, rskew_dist)
```

```{r, echo = FALSE}
load(file = url('https://github.com/anyone-can-cook/educ152/raw/main/data/ipeds/output_data/panel_data.RData'))

df_ipeds_pop <- panel_data %>%
  # keep data from fall 2019
  filter(year == 2019) %>%
  # which universities to keep:
    # 2015 carnegie classification: keep research universities (15,16,17) and master's universities with "larger programs" (18)
    # [REMOVE THIS] also keep: UC-San Francisco; and UC-Hastings College of Law
      #filter((c15basic %in% c(15,16,17,18)) | unitid %in% c(110699,110398)) %>%
  filter(c15basic %in% c(15,16,17,18)) %>%
  # keep publics and private non-profits (i.e., remove for-profits)
  filter(control %in% c(1,2)) %>%
  # which variables to keep
  select(instnm,unitid,opeid6,opeid,control,c15basic,stabbr,city,zip,locale,obereg, # basic institutional characteristics
         tuition6,fee6,tuition7,fee7, # avg tuition and fees for full-time grad, in-state and out-of-state
         isprof3,ispfee3,osprof3,ospfee3, # avg tuition and fees for MD, in-state and out-of-state
         isprof9,ispfee9,osprof9,ospfee9, # avg tuition and fees for Law, in-state and out-of-state
         chg4ay3,chg7ay3,chg8ay3) %>% # [undergraduate] books+supplies; off-campus (not with family) room and board; off-campus (not with family) other expenses
  # rename variables; syntax <new_name> = <old_name>
  rename(region = obereg, # revion
         tuit_grad_res = tuition6, fee_grad_res = fee6, tuit_grad_nres = tuition7, fee_grad_nres = fee7, # grad
         tuit_md_res = isprof3, fee_md_res = ispfee3, tuit_md_nres = osprof3, fee_md_nres = ospfee3, # md
         tuit_law_res = isprof9, fee_law_res = ispfee9, tuit_law_nres = osprof9, fee_law_nres = ospfee9, # law
         books_supplies = chg4ay3, roomboard_off = chg7ay3, oth_expense_off = chg8ay3) %>% # [undergraduate] expenses
  # create measures of tuition+fees
  mutate(
    tuitfee_grad_res = tuit_grad_res + fee_grad_res, # graduate, state resident
    tuitfee_grad_nres = tuit_grad_nres + fee_grad_nres, # graduate, non-resident
    tuitfee_md_res = tuit_md_res + fee_md_res, # MD, state resident
    tuitfee_md_nres = tuit_md_nres + fee_md_nres, # MD, non-resident
    tuitfee_law_res = tuit_law_res + fee_law_res, # Law, state resident
    tuitfee_law_nres = tuit_law_nres + fee_law_nres) %>% # Law, non-resident
  # create measures of cost-of-attendance (COA) as the sum of tuition, fees, book, living expenses
  mutate(
    coa_grad_res = tuit_grad_res + fee_grad_res + books_supplies + roomboard_off + oth_expense_off, # graduate, state resident
    coa_grad_nres = tuit_grad_nres + fee_grad_nres + books_supplies + roomboard_off + oth_expense_off, # graduate, non-resident
    coa_md_res = tuit_md_res + fee_md_res + books_supplies + roomboard_off + oth_expense_off, # MD, state resident
    coa_md_nres = tuit_md_nres + fee_md_nres + books_supplies + roomboard_off + oth_expense_off, # MD, non-resident
    coa_law_res = tuit_law_res + fee_law_res + books_supplies + roomboard_off + oth_expense_off, # Law, state resident
    coa_law_nres = tuit_law_nres + fee_law_nres + books_supplies + roomboard_off + oth_expense_off) # Law, non-resident

# Add variable labels to the tuit+fees variables and coa variables
  # tuition + fees variables
    var_label(df_ipeds_pop[['tuitfee_grad_res']]) <- 'graduate, full-time, resident; avg tuition + required fees'
    var_label(df_ipeds_pop[['tuitfee_grad_nres']]) <- 'graduate, full-time, non-resident; avg tuition + required fees'
    var_label(df_ipeds_pop[['tuitfee_md_res']]) <- 'MD, full-time, state resident; avg tuition + required fees'
    var_label(df_ipeds_pop[['tuitfee_md_nres']]) <- 'MD, full-time, non-resident; avg tuition + required fees'
    var_label(df_ipeds_pop[['tuitfee_law_res']]) <- 'Law, full-time, state resident; avg tuition + required fees'
    var_label(df_ipeds_pop[['tuitfee_law_nres']]) <- 'Law, full-time, non-resident; avg tuition + required fees'

  # COA variables
    var_label(df_ipeds_pop[['coa_grad_res']]) <- 'graduate, full-time, state resident COA; == tuition + fees + (ug) books/supplies + (ug) off-campus room and board + (ug) off-campus other expenses'
    var_label(df_ipeds_pop[['coa_grad_nres']]) <- 'graduate, full-time, non-resident COA; == tuition + fees + (ug) books/supplies + (ug) off-campus room and board + (ug) off-campus other expenses'
    var_label(df_ipeds_pop[['coa_md_res']]) <- 'MD, full-time, state resident COA; == tuition + fees + (ug) books/supplies + (ug) off-campus room and board + (ug) off-campus other expenses'
    var_label(df_ipeds_pop[['coa_md_nres']]) <- 'MD, full-time, non-resident COA; == tuition + fees + (ug) books/supplies + (ug) off-campus room and board + (ug) off-campus other expenses'
    var_label(df_ipeds_pop[['coa_law_res']]) <- 'Law, full-time, state resident COA; == tuition + fees + (ug) books/supplies + (ug) off-campus room and board + (ug) off-campus other expenses'
    var_label(df_ipeds_pop[['coa_law_nres']]) <- 'Law, full-time, non-resident COA; == tuition + fees + (ug) books/supplies + (ug) off-campus room and board + (ug) off-campus other expenses'
```


# Plot population distribution

```{r}
# Function to generate plot
plot_distribution <- function(data_vec, plot_title = '') {
  
  legend_text <- c(paste('Mean:', round(mean(data_vec, na.rm = T), 2),
                         '\nStd Dev:', round(sd(data_vec, na.rm = T), 2)),
                   paste('Median:', round(median(data_vec, na.rm = T), 2)))
  
  p <- ggplot(as.data.frame(data_vec), aes(x = data_vec)) +
    ggtitle(plot_title) + xlab('') + ylab('') +
    geom_histogram(aes(y = ..density..), alpha = 0.4, position = 'identity') +
    geom_density() +
    geom_vline(aes(xintercept = mean(data_vec, na.rm = T), color = 'mean', linetype = 'mean'),
               size = 0.8, alpha = 0.8) +
    geom_vline(aes(xintercept = median(data_vec, na.rm = T), color = 'median', linetype = 'median'),
               size = 0.8, alpha = 0.8) +
    scale_color_manual(name = 'Statistics',
                       labels = legend_text,
                       values = c(mean = 'blue', median = 'red')) +
    scale_linetype_manual(name = 'Statistics',
                          labels = legend_text,
                          values = c(mean = 'dotted', median = 'dashed')) +
    theme(plot.title = element_text(size = 10, face = 'bold', hjust = 0.5),
          legend.title = element_text(size = 9, face = 'bold'),
          legend.text = element_text(size = 8))

  p
}

# Randomly generated data: standard normal
plot_distribution(df_generated_pop$stdnorm_dist)

# Randomly generated data: normal
plot_distribution(df_generated_pop$norm_dist)

# Randomly generated data: left-skewed
plot_distribution(df_generated_pop$lskew_dist)

# Randomly generated data: right-skewed
plot_distribution(df_generated_pop$rskew_dist)

# IPEDS data: tuitfee_grad_res
plot_distribution(df_ipeds_pop$tuitfee_grad_res)
```


# Plot single random sample

```{r}
# Take single random sample of size 100
df_generated_sample <- df_generated_pop[sample(nrow(df_generated_pop), 100), ]
df_ipeds_sample <- df_ipeds_pop[sample(nrow(df_ipeds_pop), 100), ]

# Randomly generated data: standard normal
plot_distribution(df_generated_sample$stdnorm_dist)

# Randomly generated data: normal
plot_distribution(df_generated_sample$norm_dist)

# Randomly generated data: left-skewed
plot_distribution(df_generated_sample$lskew_dist)

# Randomly generated data: right-skewed
plot_distribution(df_generated_sample$rskew_dist)

# IPEDS data: tuitfee_grad_res
plot_distribution(df_ipeds_sample$tuitfee_grad_res)
```


# Plot sampling distribution

```{r}
# Function to get sampling distribution (default: 500 samples of size 100)
get_sampling_distribution <- function(data_vec, num_samples = 500, sample_size = 100) {
  sample_means <- vector(mode = 'numeric', num_samples)

  for (i in 1:length(sample_means)) {
    samp <- sample(data_vec, sample_size)
    sample_means[[i]] <- mean(samp, na.rm = T)
  }

  sample_means
}

# Randomly generated data: standard normal
plot_distribution(get_sampling_distribution(df_generated_pop$stdnorm_dist))

# Randomly generated data: normal
plot_distribution(get_sampling_distribution(df_generated_pop$norm_dist))

# Randomly generated data: left-skewed
plot_distribution(get_sampling_distribution(df_generated_pop$lskew_dist))

# Randomly generated data: right-skewed
plot_distribution(get_sampling_distribution(df_generated_pop$rskew_dist))

# IPEDS data: tuitfee_grad_res
plot_distribution(get_sampling_distribution(df_ipeds_pop$tuitfee_grad_res))
```


# Combine plots

```{r}
library(patchwork)

# Use / to place plots 1 per row (stacked)
plot_distribution(df_generated_pop$stdnorm_dist, plot_title = 'Population distribution') /
  plot_distribution(df_generated_sample$stdnorm_dist, plot_title = 'Single sample distribution') /
  plot_distribution(get_sampling_distribution(df_generated_pop$stdnorm_dist),
                    plot_title = 'Sampling distribution')

# Or use + and plot_layout()
plot_distribution(df_generated_pop$stdnorm_dist, plot_title = 'Population distribution') +
  plot_distribution(df_generated_sample$stdnorm_dist, plot_title = 'Single sample distribution') +
  plot_distribution(get_sampling_distribution(df_generated_pop$stdnorm_dist),
                    plot_title = 'Sampling distribution') +
  plot_layout(ncol = 1)
```


# Dataframe output

```{r}
df_ipeds_pop %>% head()
df_generated_pop %>% head()
```


# Hypothesis testing

```{r}
# Function to generate t-distribution plot
plot_t_distribution <- function(data_vec, mu, alpha = 0.05, alternative = 'two.sided', plot_title = '', shade_rejection = T, shade_pval = T, stacked = F) {
  
  data_vec <- na.omit(data_vec)
  
  # Calculate t-statistics
  sample_size <- length(data_vec)
  deg_freedom <- sample_size - 1
  xbar <- mean(data_vec)
  s <- sd(data_vec)
  
  std_err <- s / sqrt(sample_size)
  t <- (xbar - mu) / std_err
  
  # Calculate critical value and p-value
  if (alternative == 'less') {  # left-tailed
    cv_lower <- qt(p = alpha, df = deg_freedom, lower.tail = T)
    cv_legend <- round(cv_lower, 2)
    cv_legend2 <- round(cv_lower * std_err + mu, 2)
    pval <- round(pt(q = t, df = deg_freedom, lower.tail = T), 4)
  } else if (alternative == 'greater') {  # right-tailed
    cv_upper <- qt(p = alpha, df = deg_freedom, lower.tail = F)
    cv_legend <- round(cv_upper, 2)
    cv_legend2 <- round(cv_upper * std_err + mu, 2)
    pval <- round(pt(q = t, df = deg_freedom, lower.tail = F), 4)
  } else {  # two-tailed
    cv_lower <- qt(p = alpha / 2, df = deg_freedom, lower.tail = T)
    cv_upper <- qt(p = alpha / 2, df = deg_freedom, lower.tail = F)
    cv_legend <- str_c('\u00B1', round(cv_upper, 2))
    cv_legend2 <- str_c(round(cv_lower * std_err + mu, 2), ' & ', round(cv_upper * std_err + mu, 2))
    pval_half <- round(pt(q = t, df = deg_freedom, lower.tail = t < 0), 4)
    pval <- str_c(pval_half, ' + ', pval_half, ' = ', 2 * pval_half)
  }
  
  # Plot t-distribution
  p <- ggplot(data.frame(x = -c(-4, 4)), aes(x)) +
    ggtitle(plot_title) + xlab('') + ylab('') +
    stat_function(fun = dt, args = list(df = deg_freedom), xlim = c(-4, 4))
  
  # Shade rejection region using critical value
  if (alternative != 'greater') {
    p <- p + geom_vline(aes(xintercept = cv_lower, color = 'cval'),
                        linetype = 'dotted', size = 0.8, alpha = 0.8)
    
    if (shade_rejection) {
      p <- p + stat_function(fun = dt, args = list(df = deg_freedom),
                             xlim = c(-4, cv_lower),
                             geom = 'area', alpha = 0.3, fill = 'red')
    }
    
    if (shade_pval) {
      p <- p + stat_function(fun = dt, args = list(df = deg_freedom),
                             xlim = c(-4, if_else(alternative == 'two.sided', -abs(t), t)),
                             geom = 'area', alpha = 0.3, fill = 'blue')
    }
  }
  if (alternative != 'less') {
    p <- p + geom_vline(aes(xintercept = cv_upper, color = 'cval'),
                        linetype = 'dotted', size = 0.8, alpha = 0.8)
    
    if (shade_rejection) {
      p <- p + stat_function(fun = dt, args = list(df = deg_freedom),
                             xlim = c(cv_upper, 4),
                             geom = 'area', alpha = 0.3, fill = 'red')
    }
    
    if (shade_pval) {
      p <- p + stat_function(fun = dt, args = list(df = deg_freedom),
                             xlim = c(if_else(alternative == 'two.sided', abs(t), t), 4),
                             geom = 'area', alpha = 0.3, fill = 'blue')
    }
  }
  
  # Legend text
  legend_text <- c('t-statistics / p-value', 'critical value / alpha')
  
  if (stacked) {
    legend_text <- c(str_c('t-statistics: ', round(t, 2),
                     '\n(p-value: ', str_extract(pval, '[\\d.-]+$'), ')'),
                     str_c('Critical value: ', cv_legend,
                     '\n(alpha: ', round(alpha, 2), ')'))
  }
  
  stats_text <- c(str_c('t-statistics: ', round(t, 2)),
                  str_c('SE: ', round(std_err, 2)),
                  str_c('p-value: ', pval),
                  str_c('Critical value: ', cv_legend),
                  str_c('alpha: ', round(alpha, 2)))
  
  if (!stacked) {
    p <- p +
      annotate('text', size = 9*5/14, x = 4.84, y = 0.14, hjust = 0,
               label = 'bold(Statistics)', parse = T) +
      annotate('text', size = 8*5/14, x = 4.89, y = 0:4 * -0.015 + 0.12, hjust = 0,
               label = stats_text)
  }
  
  # Label plot
  p <- p +
    geom_vline(aes(xintercept = t, color = 'tstat'),
               linetype = 'dotted', size = 0.8, alpha = 0.8) +
    scale_x_continuous(sec.axis = sec_axis(trans = ~ . * std_err + mu)) +
    scale_color_manual(name = if_else(stacked, 'Statistics', 'Legend'),
                       breaks = c('tstat', 'cval'),
                       labels = legend_text,
                       values = c(tstat = 'blue', cval = 'red')) +
    theme(plot.title = element_text(size = 10, face = 'bold', hjust = 0.5),
          plot.margin = unit(c(5.5, if_else(stacked, 5.5, 30), 5.5, 5.5), 'pt'),
          legend.title = element_text(size = 9, face = 'bold'),
          legend.text = element_text(size = 8)) +
    coord_cartesian(xlim = c(-4, 4),
                    clip = 'off')

  p
}

# H0: population mean of coa_grad_res is $29,000
# Ha: population mean of coa_grad_res is NOT $29,000 (two-sided test)
# Verdict: Reject H0
t.test(df_ipeds_sample$coa_grad_res, mu = 29000)
plot_t_distribution(df_ipeds_sample$coa_grad_res, mu = 29000)

# H0: population mean of coa_grad_res is $32,000
# Ha: population mean of coa_grad_res is NOT $32,000 (two-sided test)
# Verdict: Fail to reject H0
t.test(df_ipeds_sample$coa_grad_res, mu = 32000)
plot_t_distribution(df_ipeds_sample$coa_grad_res, mu = 32000)

# H0: population mean of coa_grad_res is $33,000
# Ha: population mean of coa_grad_res is LESS THAN $33,000 (left-sided test)
# Verdict: Reject H0
t.test(df_ipeds_sample$coa_grad_res, mu = 33000, alternative = 'less')
plot_t_distribution(df_ipeds_sample$coa_grad_res, mu = 33000, alternative = 'less')

# H0: population mean of coa_grad_res is $31,000
# Ha: population mean of coa_grad_res is GREATER THAN $31,000 (right-sided test)
# Verdict: Fail to reject H0
t.test(df_ipeds_sample$coa_grad_res, mu = 31000, alternative = 'greater')
plot_t_distribution(df_ipeds_sample$coa_grad_res, mu = 31000, alternative = 'greater')
```


```{r}
plot_distribution(df_ipeds_sample$coa_grad_res, plot_title = 'Population distribution') +
  plot_distribution(df_ipeds_sample$coa_grad_res, plot_title = 'Single sample distribution') +
  plot_t_distribution(df_ipeds_sample$coa_grad_res, mu = 29000, plot_title = 'Sampling distribution under null', stacked = T) +
  plot_layout(ncol = 1)
```


```{r}
t.test(formula = tuitfee_grad_res ~ control, mu = 0, data = df_ipeds_sample, subset = unclass(control) != 3)
```


```{r}
# Function to generate plot
plot_distribution <- function(data_df, data_var, plot_title = '') {
  
  data_vec <- data_df[[data_var]]
  
  legend_text <- c(paste('Mean:', round(mean(data_vec, na.rm = T), 2),
                         '\nStd Dev:', round(sd(data_vec, na.rm = T), 2)),
                   paste('Median:', round(median(data_vec, na.rm = T), 2)))
  
  p <- ggplot() +
    ggtitle(plot_title) + xlab('') + ylab('') +
    geom_histogram(aes(x = data_vec, y = ..density..), alpha = 0.4, position = 'identity') +
    geom_density(aes(x = data_vec)) +
    geom_vline(aes(xintercept = mean(data_vec, na.rm = T), color = 'mean', linetype = 'mean'),
               size = 0.8, alpha = 0.8) +
    geom_vline(aes(xintercept = median(data_vec, na.rm = T), color = 'median', linetype = 'median'),
               size = 0.8, alpha = 0.8) +
    scale_color_manual(name = 'Statistics',
                       labels = legend_text,
                       values = c(mean = 'blue', median = 'red')) +
    scale_linetype_manual(name = 'Statistics',
                          labels = legend_text,
                          values = c(mean = 'dotted', median = 'dashed')) +
    theme(plot.title = element_text(size = 10, face = 'bold', hjust = 0.5),
          legend.title = element_text(size = 9, face = 'bold'),
          legend.text = element_text(size = 8))

  p
}

# Randomly generated data: standard normal
df_generated_pop %>% plot_distribution('stdnorm_dist')
```


```{r}
# Function to generate plot
plot_distribution <- function(data_df, data_var, group_var = NULL, group_cat = NULL, plot_title = '') {
  
  # If group_cat not provided, use 2 values from group_var
  if (!is.null(group_var) && is.null(group_cat)) {
    group_cat <- unique(unclass(data_df[[group_var]]))[1:2]
  }
  
  # Create population vector(s)
  if (is.null(group_var)) {
    data_vec1 <- data_df[[data_var]] %>% unclass() %>% na.omit()
  } else {
    data_vec1 <- (data_df %>% filter(unclass(get(group_var)) == group_cat[[1]]))[[data_var]] %>% unclass() %>% na.omit()
    data_vec2 <- (data_df %>% filter(unclass(get(group_var)) == group_cat[[2]]))[[data_var]] %>% unclass() %>% na.omit()
  }
  
  # Legend text
  legend_text <- c(paste('Mean:', round(mean(data_vec1), 2),
                         '\nStd Dev:', round(sd(data_vec1), 2)),
                   paste('Median:', round(median(data_vec1), 2)))
  
  # Plot distribution(s)
  p <- ggplot() +
    ggtitle(plot_title) + xlab('') + ylab('') +
    geom_histogram(aes(x = data_vec1, y = ..density..), alpha = 0.4, position = 'identity') +
    geom_density(aes(x = data_vec1)) +
    geom_vline(aes(xintercept = mean(data_vec1),
                   color = 'mean', linetype = if_else(is.null(group_var), 'dotted', 'pop1')),
               size = 0.8, alpha = 0.8) +
    geom_vline(aes(xintercept = median(data_vec1),
                   color = 'median', linetype = if_else(is.null(group_var), 'dotted', 'pop1')),
               size = 0.8, alpha = 0.8)
  
  if (!is.null(group_var)) {
    legend_text <- c(legend_text, 
                     paste('Mean:', round(mean(data_vec2), 2),
                           '\nStd Dev:', round(sd(data_vec2), 2)),
                     paste('Median:', round(median(data_vec2), 2)))
    print(legend_text)
    p <- p + 
      geom_histogram(aes(x = data_vec2, y = ..density..), fill = 'purple', alpha = 0.4, position = 'identity') +
      geom_density(aes(x = data_vec2)) +
      geom_vline(aes(xintercept = mean(data_vec2),
                     color = 'mean', linetype = 'pop2'),
                 size = 0.8, alpha = 0.8) +
      geom_vline(aes(xintercept = median(data_vec2),
                     color = 'median', linetype = 'pop2'),
                 size = 0.8, alpha = 0.8) +
      scale_linetype_manual(name = 'Statistics',
                            labels = legend_text,
                            values = rep(c(pop1 = 'dotted', pop2 = 'dashed'), each = 2))
    print(rep(c(pop1 = 'dotted', pop2 = 'dashed'), each = 2))
  }
  
  p <- p +
    scale_color_manual(name = 'Statistics',
                       labels = legend_text,
                       values = rep(c(mean = 'blue', median = 'red'), times = if_else(is.null(group_var), 1, 2))) +
    theme(plot.title = element_text(size = 10, face = 'bold', hjust = 0.5),
          legend.title = element_text(size = 9, face = 'bold'),
          legend.text = element_text(size = 8))
  print(rep(c(mean = 'blue', median = 'red'), times = if_else(is.null(group_var), 1, 2)))
  p
}

# Randomly generated data: standard normal
df_ipeds_sample %>% plot_distribution('tuitfee_grad_res', 'control')
```

```{r}
test_df <- data.frame(pop = c('dotted', 'dotted', 'dashed', 'dashed'), stat = c('blue', 'red', 'blue', 'red'), val = c(-1, 2.5, -0.5, 2))

ggplot() +
  geom_vline(data = test_df, aes(xintercept = val, color = interaction(stat, pop), linetype = interaction(stat, pop))) +
  scale_color_manual(name = 'Statistics',
                     labels = c('a', 'b', 'c', 'd'),
                     values = as.character(test_df$stat)) +
  scale_linetype_manual(name = 'Statistics',
                     labels = c('a', 'b', 'c', 'd'),
                     values = as.character(test_df$pop))
```


```{r}
# Function to generate plot
plot_distribution <- function(data_df, data_var, group_var = NULL, group_cat = NULL, plot_title = '') {
  
  # Prep dataframe
  two_pop <- !is.null(group_var)
  
  data_df[[data_var]] <- unclass(data_df[[data_var]])  # unclass haven_labelled
  if (two_pop) {
    data_df[[group_var]] <- unclass(data_df[[group_var]])
  }
  
  data_df <- data_df %>% filter(!is.na(get(data_var)))  # remove NA rows
  
  # If group_cat not provided, use 2 values from group_var
  if (two_pop && is.null(group_cat)) {
    group_cat <- sort(unique(na.omit(data_df[[group_var]])))[1:2]
  }

  # Create population vector(s)
  if (!two_pop) {  # single population
    data_vec1 <- data_df[[data_var]]
    
    lines_vec <- c('dotted')
    stats_vec <- c(mean(data_vec1), median(data_vec1))
    legend_title <- 'Statistics'
  } else {  # two populations
    data_vec1 <- (data_df %>% filter(get(group_var) == group_cat[[1]]))[[data_var]]
    data_vec2 <- (data_df %>% filter(get(group_var) == group_cat[[2]]))[[data_var]]
    
    lines_vec <- c('dotted', 'dotdash')
    stats_vec <- c(mean(data_vec1), median(data_vec1), mean(data_vec2), median(data_vec2))
    legend_title <- paste0('Statistics\n(', group_var, '=', group_cat[[1]], ' vs. ', group_var, '=', group_cat[[2]], ')')
  }
  
  # Create statistics dataframe
  stats_df <- data.frame(
    pop = rep(lines_vec, each = 2),
    stat = rep(c('blue', 'red'), times = if_else(two_pop, 2, 1)),
    val = stats_vec
  )
  
  # Legend text
  legend_text <- c(paste('Mean:', round(mean(data_vec1), 2),
                         '\nStd Dev:', round(sd(data_vec1), 2)),
                   paste('Median:', round(median(data_vec1), 2)))
  
  if (two_pop) {
    legend_text <- c(legend_text, 
                     paste('Mean:', round(mean(data_vec2), 2),
                           '\nStd Dev:', round(sd(data_vec2), 2)),
                     paste('Median:', round(median(data_vec2), 2)))
  }
  
  # Plot distribution(s)
  p <- ggplot() +
    ggtitle(plot_title) + xlab('') + ylab('') +
    geom_histogram(aes(x = data_vec1, y = ..density..), alpha = 0.4, position = 'identity') +
    geom_density(aes(x = data_vec1))
  
  if (two_pop) {
    p <- p + 
      geom_histogram(aes(x = data_vec2, y = ..density..), alpha = 0.4, position = 'identity', fill = 'wheat4') +
      geom_density(aes(x = data_vec2))
  }
  
  p <- p +
    geom_vline(data = stats_df,
               aes(xintercept = val, color = interaction(stat, pop), linetype = interaction(stat, pop)),
               size = 0.6, alpha = 0.8) +
    scale_color_manual(name = legend_title,
                       labels = legend_text,
                       values = as.character(stats_df$stat)) +
    scale_linetype_manual(name = legend_title,
                          labels = legend_text,
                          values = as.character(stats_df$pop)) +
    theme(plot.title = element_text(size = 10, face = 'bold', hjust = 0.5),
          legend.title = element_text(size = 9, face = 'bold'),
          legend.text = element_text(size = 8)) +
    guides(col = guide_legend(ncol = if_else(two_pop, 2, 1)))
  
  p
}


# Randomly generated data: standard normal
df_ipeds_sample %>% plot_distribution('tuitfee_grad_res', 'control')

# Randomly generated data: standard normal
df_ipeds_sample %>% plot_distribution('tuitfee_grad_res')
```

```{r}
ggplot(mtcars, aes(mpg, wt, color = gear,fill = "a")) + 
  geom_point() + labs(caption = "Your text here") +
  scale_fill_manual(name = "Your custom caption\ngoes here", labels = '', values = c('white')) + 
  theme(legend.key = element_rect(fill = "white"),
        plot.caption = element_text(colour = "red", hjust = 1, angle = 15)) +
  guides(color = guide_legend(order = 2),
      fill = guide_legend(order = 1, title.vjust = 5,
                          override.aes = list(linetype = 0, shape=NA))) # setting the order parameter in guide_legend will help place it below your existing legend(s)
```

